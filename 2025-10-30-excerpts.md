## `src/graph/KnowledgeGraphManager.ts`
<KnowledgeGraphManager.ts-L1-L16>
```
import { loadGraph as loadGraphFile, saveGraph as saveGraphFile } from "../storage/graphStore.js";
import { VALID_RELATION_TYPES, VALID_STATUS_VALUES, VALID_PRIORITY_VALUES } from "../constants/domain.js";
import type { EntityType } from "../constants/domain.js";
import { validateEntityType } from "../utils/validate.js";
import type { Entity, Relation, KnowledgeGraph } from "../types/graph.js";

type Embedding = number[];

export class KnowledgeGraphManager {
  public async loadGraph(): Promise<KnowledgeGraph> {
    return await loadGraphFile();
  }

  private async saveGraph(graph: KnowledgeGraph): Promise<void> {
    await saveGraphFile(graph);
  }
```
</KnowledgeGraphManager.ts-L1-L16>

<KnowledgeGraphManager.ts-L48-L127>
```
  // Helper method to get status of an entity
  async getEntityStatus(entityName: string): Promise<string | null> {
    const graph = await this.loadGraph();
    
    // Find status relation for this entity
    const statusRelation = graph.relations.find(r => 
      r.from === entityName && 
      r.relationType === 'has_status'
    );
    
    if (statusRelation) {
      // Extract status value from the status entity name (status:value)
      return statusRelation.to.split(':')[1];
    }
    
    return null;
  }
  
  // Helper method to get priority of an entity
  async getEntityPriority(entityName: string): Promise<string | null> {
    const graph = await this.loadGraph();
    
    // Find priority relation for this entity
    const priorityRelation = graph.relations.find(r => 
      r.from === entityName && 
      r.relationType === 'has_priority'
    );
    
    if (priorityRelation) {
      // Extract priority value from the priority entity name (priority:value)
      return priorityRelation.to.split(':')[1];
    }
    
    return null;
  }
  
  // Helper method to set status of an entity
  async setEntityStatus(entityName: string, statusValue: string): Promise<void> {
    if (!(VALID_STATUS_VALUES as readonly string[]).includes(statusValue)) {
      throw new Error(`Invalid status value: ${statusValue}. Valid values are: ${VALID_STATUS_VALUES.join(', ')}`);
    }
    
    const graph = await this.loadGraph();
    
    // Remove any existing status relations for this entity
    graph.relations = graph.relations.filter(r => 
      !(r.from === entityName && r.relationType === 'has_status')
    );
    
    // Add new status relation
    graph.relations.push({
      from: entityName,
      to: `status:${statusValue}`,
      relationType: 'has_status'
    });
    
    await this.saveGraph(graph);
  }
  
  // Helper method to set priority of an entity
  async setEntityPriority(entityName: string, priorityValue: string): Promise<void> {
    if (!(VALID_PRIORITY_VALUES as readonly string[]).includes(priorityValue)) {
      throw new Error(`Invalid priority value: ${priorityValue}. Valid values are: ${VALID_PRIORITY_VALUES.join(', ')}`);
    }
    
    const graph = await this.loadGraph();
    
    // Remove any existing priority relations for this entity
    graph.relations = graph.relations.filter(r => 
      !(r.from === entityName && r.relationType === 'has_priority')
    );
    
    // Add new priority relation
    graph.relations.push({
      from: entityName,
      to: `priority:${priorityValue}`,
      relationType: 'has_priority'
    });
    
    await this.saveGraph(graph);
```
</KnowledgeGraphManager.ts-L48-L127>

<KnowledgeGraphManager.ts-L242-L303>
```
  async readGraph(): Promise<KnowledgeGraph> {
    return await this.loadGraph();
  }

  async searchNodes(query: string): Promise<KnowledgeGraph> {
    const graph = await this.loadGraph();
    const lowerQuery = query.toLowerCase();
    
    // Simple implementation: search entity names, types, and observations
    const matchingEntities = graph.entities.filter(entity => 
      entity.name.toLowerCase().includes(lowerQuery) ||
      entity.entityType.toLowerCase().includes(lowerQuery) ||
      entity.observations.some(o => o.toLowerCase().includes(lowerQuery))
    );
    
    // Get entity names for filtering relations
    const matchingEntityNames = new Set(matchingEntities.map(e => e.name));
    
    // Find relations between matching entities
    const matchingRelations = graph.relations.filter(relation =>
      matchingEntityNames.has(relation.from) && matchingEntityNames.has(relation.to)
    );
    
    // Also include relations where the relation type matches the query
    const additionalRelations = graph.relations.filter(relation =>
      relation.relationType.toLowerCase().includes(lowerQuery) ||
      (relation.observations && relation.observations.some(o => o.toLowerCase().includes(lowerQuery)))
    );
    
    // Merge relations without duplicates
    const allRelations = [...matchingRelations];
    for (const relation of additionalRelations) {
      if (!allRelations.some(r => 
        r.from === relation.from && 
        r.to === relation.to && 
        r.relationType === relation.relationType
      )) {
        allRelations.push(relation);
        
        // Add the entities involved in these additional relations
        if (!matchingEntityNames.has(relation.from)) {
          const fromEntity = graph.entities.find(e => e.name === relation.from);
          if (fromEntity) {
            matchingEntities.push(fromEntity);
            matchingEntityNames.add(relation.from);
          }
        }
        
        if (!matchingEntityNames.has(relation.to)) {
          const toEntity = graph.entities.find(e => e.name === relation.to);
          if (toEntity) {
            matchingEntities.push(toEntity);
            matchingEntityNames.add(relation.to);
          }
        }
      }
    }
    
    return {
      entities: matchingEntities,
      relations: allRelations
    };
```
</KnowledgeGraphManager.ts-L242-L303>

## `src/mcp/tools/startsession.ts`
<startsession.ts-L32-L176>
```
      const projectsQuery = await kgm.searchNodes("entityType:project");
      const projects: any[] = [];

      for (const project of projectsQuery.entities) {
        const status = await kgm.getEntityStatus(project.name);
        if (status === "active") {
          projects.push(project);
        }
      }

      const taskQuery = await kgm.searchNodes("entityType:task");
      const tasks: any[] = [];

      for (const task of taskQuery.entities) {
        const status = await kgm.getEntityStatus(task.name);
        const priority = await kgm.getEntityPriority(task.name);

        if (status === "active" && priority === "high") {
          tasks.push(task);
        }
      }

      const milestoneQuery = await kgm.searchNodes("entityType:milestone");
      const milestones: any[] = [];

      for (const milestone of milestoneQuery.entities) {
        const status = await kgm.getEntityStatus(milestone.name);
        if (status === "planned" || status === "approaching") {
          milestones.push(milestone);
        }
      }

      const riskQuery = await kgm.searchNodes("entityType:risk");
      const risks: any[] = [];

      for (const risk of riskQuery.entities) {
        const priority = await kgm.getEntityPriority(risk.name);
        if (priority === "high") {
          risks.push(risk);
        }
      }

      const projectsText = await Promise.all(
        projects.map(async (p) => {
          const status = (await kgm.getEntityStatus(p.name)) || "Unknown";
          const priority = await kgm.getEntityPriority(p.name);
          const priorityText = priority ? `, Priority: ${priority}` : "";

          const preview =
            p.observations.length > 0
              ? `${p.observations[0].substring(0, 60)}${
                  p.observations[0].length > 60 ? "..." : ""
                }`
              : "No description";

          return `- **${p.name}** (Status: ${status}${priorityText}): ${preview}`;
        })
      );

      const tasksText = await Promise.all(
        tasks.slice(0, 10).map(async (t) => {
          const status = (await kgm.getEntityStatus(t.name)) || "Unknown";
          const priority = (await kgm.getEntityPriority(t.name)) || "Unknown";
          const projectObs = t.observations.find((o: string) => o.startsWith("project:"));
          const project = projectObs ? projectObs.substring(8) : "Unknown project";

          const nonProjectObs = t.observations.find((o: string) => !o.startsWith("project:"));
          const preview =
            nonProjectObs
              ? `${nonProjectObs.substring(0, 60)}${
                  nonProjectObs.length > 60 ? "..." : ""
                }`
              : "No description";

          return `- **${t.name}** (Project: ${project}, Status: ${status}, Priority: ${priority}): ${preview}`;
        })
      );

      const milestonesText = await Promise.all(
        milestones.slice(0, 8).map(async (m) => {
          const status = (await kgm.getEntityStatus(m.name)) || "Unknown";
          const projectObs = m.observations.find((o: string) => o.startsWith("project:"));
          const project = projectObs ? projectObs.substring(8) : "Unknown project";

          const nonProjectObs = m.observations.find((o: string) => !o.startsWith("project:"));
          const preview =
            nonProjectObs
              ? `${nonProjectObs.substring(0, 60)}${
                  nonProjectObs.length > 60 ? "..." : ""
                }`
              : "No description";

          return `- **${m.name}** (Project: ${project}, Status: ${status}): ${preview}`;
        })
      );

      const risksText = await Promise.all(
        risks.slice(0, 5).map(async (r) => {
          const priority = (await kgm.getEntityPriority(r.name)) || "Unknown";
          const projectObs = r.observations.find((o: string) => o.startsWith("project:"));
          const project = projectObs ? projectObs.substring(8) : "Unknown project";

          const nonProjectObs = r.observations.find((o: string) => !o.startsWith("project:"));
          const preview =
            nonProjectObs
              ? `${nonProjectObs.substring(0, 60)}${
                  nonProjectObs.length > 60 ? "..." : ""
                }`
              : "No description";

          return `- **${r.name}** (Project: ${project}, Priority: ${priority}): ${preview}`;
        })
      );

      const sessionsText = recentSessions
        .map((s) => `- ${s.project} - ${s.summary.substring(0, 60)}${s.summary.length > 60 ? "..." : ""}`)
        .join("\n");

      return {
        content: [
          {
            type: "text",
            text: `# Choose what to focus on in this session

## Session ID
\`${sessionId}\`

## Recent Project Management Sessions
${sessionsText || "No recent sessions found."}

## Active Projects
${projectsText.join("\n") || "No active projects found."}

## High-Priority Tasks
${tasksText.join("\n") || "No high-priority tasks found."}

## Upcoming Milestones
${milestonesText.join("\n") || "No upcoming milestones found."}

## Top Project Risks
${risksText.join("\n") || "No high severity risks identified."}

To load specific project context, use the \`loadcontext\` tool with the project name and session ID - ${sessionId}`
          }
        ]
```
</startsession.ts-L32-L176>

## `src/mcp/tools/loadcontext.ts`
<loadcontext.ts-L78-L157>
```
          // Format tasks
          const tasksText = await Promise.all((projectOverview.tasks || []).map(async (task: Entity) => {
            const taskStatus = await kgm.getEntityStatus(task.name) || "Unknown";
            const taskPriority = await kgm.getEntityPriority(task.name) || "Not set";
            // Find the first observation that doesn't look like metadata
            const description = task.observations.find(o => 
              !o.startsWith('Project:') && 
              !o.includes(':')
            ) || "No description";
            
            return `- **${task.name}** (Status: ${taskStatus}, Priority: ${taskPriority}): ${description}`;
          }));
          
          // Format milestones
          const milestonesText = await Promise.all((projectOverview.milestones || []).map(async (milestone: Entity) => {
            const milestoneStatus = await kgm.getEntityStatus(milestone.name) || "Unknown";
            // Find the first observation that doesn't look like metadata
            const description = milestone.observations.find(o => 
              !o.startsWith('Project:') && 
              !o.includes(':')
            ) || "No description";
            
            return `- **${milestone.name}** (Status: ${milestoneStatus}): ${description}`;
          }));
          
          // Format issues
          const issuesText = await Promise.all((projectOverview.issues || []).map(async (issue: Entity) => {
            const issueStatus = await kgm.getEntityStatus(issue.name) || "Unknown";
            const issuePriority = await kgm.getEntityPriority(issue.name) || "Not set";
            // Find the first observation that doesn't look like metadata
            const description = issue.observations.find(o => 
              !o.startsWith('Project:') && 
              !o.includes(':')
            ) || "No description";
            
            return `- **${issue.name}** (Status: ${issueStatus}, Priority: ${issuePriority}): ${description}`;
          }));
          
          // Format team members
          const teamMembersText = (projectOverview.teamMembers || []).map((member: Entity) => {
            const role = member.observations.find(o => o.startsWith('Role:'))?.split(':', 2)[1]?.trim() || 'Not specified';
            return `- **${member.name}** (Role: ${role})`;
          }).join("\n") || "No team members found";
          
          // Format risks
          const risksText = await Promise.all((projectOverview.risks || []).map(async (risk: Entity) => {
            const riskStatus = await kgm.getEntityStatus(risk.name) || "Unknown";
            const riskPriority = await kgm.getEntityPriority(risk.name) || "Not set";
            // Find the first observation that doesn't look like metadata
            const description = risk.observations.find(o => 
              !o.startsWith('Project:') && 
              !o.includes(':')
            ) || "No description";
            
            return `- **${risk.name}** (Status: ${riskStatus}, Priority: ${riskPriority}): ${description}`;
          }));
          
          contextMessage = `# Project Context: ${entityName}

  ## Project Overview
  - **Status**: ${status}
  ${priorityText}

  ## Observations
  ${observationsList}

  ## Tasks (${projectOverview.summary.completedTasks || 0}/${projectOverview.summary.taskCount || 0} completed)
  ${tasksText.join("\n") || "No tasks found"}

  ## Milestones
  ${milestonesText.join("\n") || "No milestones found"}

  ## Issues
  ${issuesText.join("\n") || "No issues found"}

  ## Team Members
  ${teamMembersText}

  ## Risks
  ${risksText.join("\n") || "No risks found"}`;
```
</loadcontext.ts-L78-L157>

## `src/config/paths.ts`
<paths.ts-L4-L20>
```
const parentPath = path.dirname(fileURLToPath(import.meta.url));
const defaultMemoryPath = path.join(parentPath, "memory.json");
const defaultSessionsPath = path.join(parentPath, "sessions.json");

export const MEMORY_FILE_PATH =
  process.env.MEMORY_FILE_PATH
    ? (path.isAbsolute(process.env.MEMORY_FILE_PATH)
        ? process.env.MEMORY_FILE_PATH
        : path.join(process.cwd(), process.env.MEMORY_FILE_PATH))
    : defaultMemoryPath;

export const SESSIONS_FILE_PATH =
  process.env.SESSIONS_FILE_PATH
    ? (path.isAbsolute(process.env.SESSIONS_FILE_PATH)
        ? process.env.SESSIONS_FILE_PATH
        : path.join(process.cwd(), process.env.SESSIONS_FILE_PATH))
    : defaultSessionsPath;
```
</paths.ts-L4-L20>

## `src/utils/ids.ts`
<ids.ts-L1-L3>
```
export function generateSessionId(): string {
  return `proj_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}
```
</ids.ts-L1-L3>

## `src/storage/sessionStore.ts`
<sessionStore.ts-L4-L27>
```
export async function loadSessionStates(): Promise<Map<string, any[]>> {
  try {
    const fileContent = await fs.readFile(SESSIONS_FILE_PATH, "utf-8");
    const sessions = JSON.parse(fileContent);
    const sessionsMap = new Map<string, any[]>();
    for (const [key, value] of Object.entries(sessions)) {
      sessionsMap.set(key, value as any[]);
    }
    return sessionsMap;
  } catch (error: any) {
    if (error && error.code === "ENOENT") {
      return new Map<string, any[]>();
    }
    throw error;
  }
}

export async function saveSessionStates(sessionsMap: Map<string, any[]>): Promise<void> {
  const sessions: Record<string, any[]> = {};
  for (const [key, value] of sessionsMap.entries()) {
    sessions[key] = value;
  }
  await fs.writeFile(SESSIONS_FILE_PATH, JSON.stringify(sessions, null, 2), "utf-8");
}
```
</sessionStore.ts-L4-L27>

## `index.ts`
<index.ts-L13-L19>
```
import { startServer } from "./src/server.js";
export { KnowledgeGraphManager } from "./src/graph/KnowledgeGraphManager.js";

startServer().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
```
</index.ts-L13-L19>

## `src/server.ts`
<server.ts-L1-L24>
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import * as path from "path";
import { fileURLToPath } from "url";

import { KnowledgeGraphManager } from "./graph/KnowledgeGraphManager.js";
import { registerAll } from "./mcp/registerTools.js";
import { loadToolDescriptions } from "./utils/toolDescriptions.js";

export async function startServer() {
  const kgm = new KnowledgeGraphManager();
  await kgm.initializeStatusAndPriority();

  const server = new McpServer({ name: "Context Manager", version: "1.0.0" });

  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const descriptions = loadToolDescriptions(__dirname);

  registerAll(server, descriptions, kgm);

  const transport = new StdioServerTransport();
  await server.connect(transport);
}
```
</server.ts-L1-L24>

## `src/mcp/registerTools.ts`
<registerTools.ts-L5-L27>
```
import { registerStartSession } from "./tools/startsession.js";
import { registerLoadContext } from "./tools/loadcontext.js";
import { registerEndSession } from "./tools/endsession.js";
import { registerBuildContext } from "./tools/buildcontext.js";
import { registerDeleteContext } from "./tools/deletecontext.js";
import { registerAdvancedContext } from "./tools/advancedcontext.js";
import { registerGraphResource } from "./resourceGraph.js";

type Descriptions = Record<ToolKey, string>;

export function registerAll(
  server: McpServer,
  desc: Descriptions,
  kgm: KnowledgeGraphManager
) {
  registerGraphResource(server, kgm);
  registerStartSession(server, desc, kgm);
  registerLoadContext(server, desc, kgm);
  registerEndSession(server, desc, kgm);
  registerBuildContext(server, desc, kgm);
  registerDeleteContext(server, desc, kgm);
  registerAdvancedContext(server, desc, kgm);
}
```
</registerTools.ts-L5-L27>
